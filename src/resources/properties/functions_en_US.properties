# To change this template, choose Tools | Templates
# and open the template in the editor.
msg_search=\n\ \ \ \ function search ( k, b )  return TObjeto \n             var\n                 found : boolean\n                 actual : *nodo \n             fvar\n             actual := root\n             found := false \n             while !found && actual != null do\n                     si actual.key = k then \n                             found := true \n                     else if actual.key ? k then \n                             actual := actual.fr \n                     else \n                             actual := actual.fl \n                     endif \n             end while \n             if found then \n                     b := true \n                     return actual.val \n             else \n                     b := false \n                     return anything \n             end if \n     end function\n
msg_b_insert=\n\ \ \ \ function insert (r, dato) return BNode<T> \n        var\n            compare: Integer \n        fvar\n        if !find(data) then \n            if r==null then\n                return CreateRoot(data) \n            end if \n            compare:=Compare(r.Value,data) \n            si compare>0 then \n                r.InsertNodeLeft(data) \n            else \n                r.InsertNodeRight(data) \n            end if \n        end if \n    end function \n
msg_b_delete=\ \ function delete ( current_node , exist_key ) return BNode<T> is\n        var\n            comparationtion: Integer\n            switch_node: BNode<T>\n            aux: Integer\n        fvar\n        if current_node == null then return nul end if\n        comparationtion := compare (current_node.key,exist_key)\n        if comparation > 0 then\n            current_node.leftNode := delete(current_node.leftNode, exist_key);\n        else if\n            if comparation < 0 then\n                current_node.rightNode := delete(current_node.rightNode, exist_key);\n            else if\n                 if current_node.leftNode<>null && current_node.rightNode<>null then\n                    switch_node := searchMIn(current_node.rightNode)\n                    aux := switch_node.key\n                    current_node.rightNode= delete(current_node.rightNode,exist_key)\n                else if\n                    if current_node<>null then\n                        current_node:=current_node.leftNode\n                    else if\n                        current_node:=current_node.rightNode\n                    end if\n                end if\n            end if\n        end if\n        return current_node;\n    end function
msg_father=\n\ \ \ \ function getFather (node, key) return BNode<T> is\n      var\n         y: BNode<T>\n      fvar\n      if node == null then return nulo fsi\n      if node.leftNode <> null && node.leftNode.key == key then\n         return node\n      end if\n      y:= getFather(node.leftNode,key)\n      if y == null then\n         return getFather(node.rightNode,key)\n      else if\n         return y\n      end if\n   end function
msg_getLeaves=\n\ \ \ \ function getLeaves (current_node, list_leaves) is\n        if current_node <> null llavors\n            if isLeaf(current_node) llavors\n                addLeaf(list_leaves,current_node.key)\n            end if\n            if current_node.leftNode <> null llavors\n                getLeaves(current_node.leftNode,list_leaves)\n            end if\n\t    if current_node.rightNode<>null llavors  \n                getLeaves(current_node.rightNode,list_leaves)\n             end if\n        end if\n    end function
msg_cutLeaves=\ \ \ \ function cutLeaves is\n        var\n            it: Iterador<T>\n        fvar\n        it:= cutLeaves();\n        while !isEnd(it) do\n            delete (it.key);\n        end while\n    end function
msg_avl_insert=\n\ \ \ function insert (current_node, new_node) return boolean is\n      if current_node == null then \n         root = new_node \n      else\n         if new_node.key < current_node.key then\n            if current_node == null then\n               current_node.leftNode = new_node\n               new_node.root = current_node\n               recursiveBalance (current_node)\n            else\n               insert(current_node.leftNode,new_node)\n            end if\n         else if new_node.key > current_node.key then\n            if current_node.nodeDret == null then\n               current_node.nodeDret = new_node\n               new_node.root = current_node\n               recursiveBalance(current_node)\n            else\n               insert(current_node,new_node)\n            end if\n         else\n            return null\n         end if\n      end if\n   ffunction
msg_avl_delete=\n\ \ \ function delete (current_node, new_node) retorna Objetc is\n      if current_node == nulo then \n\tretorna nulo\n      sino\n         if current_node.valor > new_node then\n            delete (current_node.nodeEsq,new_node)\n         else if current_node.valor < new_node then\n            delete (current_node.nodoDret,new_node)\n         else if current_node.valor == new_node then\n            deleteNode (current_node)\n         end if\n      end if\n   ffunction
msg_rb_insert=\ \ \ function add (new_node) is\n      var\n         y: RBNode<T>\n         x: RBNode<T>\n      fvar\n      while !empty(x) do\n         y = x;\n         if new_node.key < x.key then\n            x.numLeft = x.numLeft + 1\n            x = x.leftNode\n         else\n            x.numRight = x.numRight + 1\n            x = x.rightNode\n         fsi\n      fwhile\n      new_node.root = y\n      if empty(y)\n         root = new_node\n      else if new_node.key < y.key then\n         y.leftNode = z\n      else\n         y.rightNode = z\n      fsi\n      new_node.leftNode = node_empty\n      new_node.rightNode = node_empty\n      new_node.color = RED\n      modifyNum(new_node)\n   ffunction
msg_rb_delete=\ \ \ function delete (key) return TObject is\n      var\n         y := RBNode<T>\n         x := RBNode<T>\n         new_node := findNode(key)\n      fvar\n      y :=  empty\n      x :=  empty\n      if empty(node.leftNode || node.rightNode) then\n         y = node;\n      else\n         treeSuccessor(new_node)\n      end if\n      if !empty(y.leftNode) then\n         x := y.leftNode\n      else \n         x := y.rightNode\n      end if\n      x.root := y.root\n      if empty(y.root) then\n         x.root := x\n      else if !isEmpty(y.root.nodeLeft) && y.root.nodeLeft == y\n         y.root.nodeLeft := x\n      else if !isEmpty(y.root.nodeRight) && y.root.nodeRight == y\n         y.root.nodeRight := x\n      end if\n      if y <> new_node then\n         new_node.key := y.key\n      end if\n      fixNodeData (x,y)\n      if y.color == BLACK then\n         deleteModifyNum(x)\n      end if\n      return key     \n   ffunction
