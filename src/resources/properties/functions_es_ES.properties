# To change this template, choose Tools | Templates
# and open the template in the editor.
msg_search=\n\ \ \ \ funci\u00f3n consultar ( k, b )  devuelve TObjeto es \n             var\n                 encontrado : booleano\n                 actual : *nodo \n             fvar\n             actual := arrel\n             encontrado := falso \n             mientras !encontrado && actual != null hacer\n                     si actual.clave = k entonces \n                             encontrado := cierto \n                     sino si actual.clave ? k entonces \n                             actual := actual.fd \n                     sino \n                             actual := actual.fe \n                     fsi \n             fmientras \n             si encontrado entonces \n                     b := cierto \n                     devuelve actual.val \n             sino \n                     b := falso \n                     no devuelve nada \n             fsi \n     ffunci\u00f3n\n
msg_b_insert=\n\ \ \ \ funci\u00f3n insertar (r, dato) devuelve NodoB<T> es \n        var\n            compara: Entero \n        fvar\n        si !buscar(dato) entonces \n            si r==null entonces\n                retorna CrearRaiz(dato) \n            fsi \n            compara:=Comparar(r.Valor,dato) \n            si compara>0 entonces \n                r.InsertarNodoIzq(dato) \n            sino \n                r.InsertarNodoDer(dato) \n            fsi \n        fsi \n    ffunci\u00f3n \n
msg_b_delete=\n\ \ \ \ funci\u00f3n borrar ( nodo_actual , valor_existente ) devuelve BNodo<T> es\n        var\n            compara: Entero\n            nodo_a_cambiar: BNode<T>\n            aux: Entero\n        fvar\n        si nodo_actual == null entonces retorna nulo fsi\n        compara := Comparar (nodo_actual.valor,valor_existente)\n        si compara > 0 entonces\n            nodo_actual.nodoIzquierdo := borrar(nodo_actual.nodoIzquierdo, valor_existente);\n        sino\n            si compara < 0 entonces\n                nodo_actual.nodoDerecho := borrar(nodo_actual.nodoDerecho, valor_existente);\n            sino\n                 si nodo_actual.nodoIzquierdo <> null && nodo_actual.nodoDerecho <> null entonces\n                    nodo_a_cambiar := buscarMinimo(nodo_actual.nodoDerecho)\n                    aux := nodo_a_cambiar.valor\n                    nodo_actual.nodoDerecho = borrar(nodo_actual.nodoDerecho,valor_existente)\n                sino\n                    si nodo_actual <> null entonces\n                        nodo_actual := nodo_actual.nodoIzquierdo\n                    sino\n                        nodo_actual := nodo_actual.nodoDerecho\n                    fsi\n                fsi\n            fsi\n        fsi\n        retorna nodo_actual;\n    ffuncion
msg_father=\n\ \ \ \ funci\u00f3n retornarPadre nodo, valor retorna nodo es\n      var\n         y:Nodo\n      fvar\n      si nodo == null entonces retorna nulo fsi\n      si nodo.nodoIzquierdo <> null && nodo.nodoIzquierdo.valor == valor entonces\n         retorna nodo\n      fsi\n      y:= retornarPadre(nodo.nodoIzquierdo,valor)\n      si y == null entonces\n         retorna retornarPadre(nodo.nodoDerecho,valor)\n      sino\n         retorna y\n      fsi\n   ffunci\u00f3n
msg_cutLeaves=\n\ \ \ \ funci\u00f3n podar es\n        var\n            it: Iterador<T>\n        fvar\n        it:= retornarHojas();\n        mientras !esFinal(it) hacer\n            borrar (it.valor);\n        fmientras\n    ffunci\u00f3n
msg_getLeaves=\n\ \ \ \ funci\u00f3n retornarHojas (nodo_actual, lista_hojas) es\n        si nodo_actual<> null entonces\n            si esHoja(nodo_actual) entonces\n                a\u00f1adirHoja(lista_hojas,nodo_actual.valor)\n            fsi\n            si nodo_actual.nodoIzquierdo<>null entonces\n                retornarHojas(nodo_actual.nodoIzquierdo,lista_hojas)\n            fsi\n\t    si nodo_actual.nodoDerecho<>null entonces  \n                retornarHojas(nodo_actual.nodoDerecho,lista_hojas)\n             fsi\n        fsi\n    ffunci\u00f3n
msg_avl_insert=\n\ \ \ funci\u00f3n insertar (nodo_actual, nuevo_nodo) retorna boleano es\n      si nodo_actual == nulo entonces \n         raiz = nuevo_nodo \n      sino\n         si nuevo_nodo.valor < nodo_actual.valor entonces\n            si nodo_actual == nulo entonces\n               nodo_actual.nodoIzquierdo = nuevo_nodo\n               nuevo_nodo.raiz = nodo_actual\n               balanceRecursivo (nodo_actual)\n            sino\n               insertar(nodo_actual.nodoIzquierdo,nuevo_nodo)\n            fsi\n         sino si nuevo_nodo.valor > nodo_actual.valor entonces\n            si nodo_actual.nodoDerecho == nulo entonces\n               nodo_actual.nodoDerecho = nuevo_nodo\n               nuevo_nodo.raiz = nodo_actual\n               balanceRecursivo(nodo_actual)\n            sino\n               insertar(nodo_actual,nuevo_nodo)\n            fsi\n         sino\n            retorna nulo\n         fsi\n      fsi\n   ffunci\u00f3n
msg_avl_delete=\n\ \ \ funci\u00f3n borrar (nodo_actual, nuevo_valor) retorna Objeto es\n      si nodo_actual == nulo entonces \n\tretorna nulo\n      sino\n         si nodo_actual.valor > nuevo_valor entonces\n            borrar (nodo_actual.nodoIzquierdo,nuevo_valor)\n         sino si nodo_actual.valor < nuevo_valor entonces\n            borrar (nodo_actual.nodoDerecho,nuevo_valor)\n         sino si nodo_actual.valor == nuevo_valor entonces\n            borrarNodo (nodo_actual)\n         fsi\n      fsi\n   ffunci\u00f3n
msg_rb_insert=\ \ \ funci\u00f3n insertar (nuevo_nodo) es\n      var\n         y: RBNode<T>\n         x: RBNode<T>\n      fvar\n      mientras !vacio(x) hacer\n         y = x;\n         si nuevo_nodo.valor < x.valor entonces\n            x.numIzquierdo = x.numIzquierdo + 1\n            x = x.nodoIzquierdo\n         sino\n            x.numDerecho = x.numDerecho + 1\n            x = x.nodoDerecho\n         fsi\n      fmientras\n      nuevo_nodo.raiz = y\n      si vacio(y)\n         raiz = nuevo_nodo\n      sino si nuevo_nodo.valor < y.valor entonces\n         y.nodoIzquierdo = z\n      sino\n         y.nodoDerecho = z\n      fsi\n      nuevo_nodo.nodoIzquierdo = nodo_vacio\n      nuevo_nodo.nodoDerecho = nodo_vacio\n      nuevo_nodo.color = ROJO\n      modificarNum(nuevo_nodo)\n   ffunci\u00f3n
msg_rb_delete=\ \ \ funci\u00f3n borrar (valor) retorna TObject es\n      var\n         y: RBNode<T>\n         x: RBNode<T>\n         nuevo_nodo := buscarNodo(valor)\n      fvar\n      y := vacio\n      x := vacio\n      si vacio(node.nodoIzquierdo || node.nodoDerecho) entonces\n         y := node;\n      sino\n         buscarSucesor(nuevo_nodo)\n      fsi\n      si !vacio(y.nodoIzquierdo) entonces\n         x := y.nodoIzquierdo\n      sino \n         x := y.nodoDerecho\n      fsi\n      x.raiz := y.raiz\n      si vacio(y.raiz) entonces\n         x.raiz := x\n      sino si !esVacio(y.raiz.nodoIzquierdo) && y.raiz.nodoIzquierdo == y\n         y.raiz.nodoIzquierdo := x\n      sino si !esVacio(y.raiz.nodoDerecho) && y.raiz.nodoDerecho == y\n         y.raiz.nodoDerecho := x\n      fsi\n      si y <> nuevo_nodo entonces\n         nuevo_nodo.valor := y.valor\n      fsi\n      fixNodeData (x,y)\n      si y.color == NEGRO entonces\n         ModificarNumero(x)\n      fsi\n      retorna valor     \n   ffunci\u00f3n\n\n\n            \n            
