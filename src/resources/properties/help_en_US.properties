# To change this template, choose Tools | Templates 
# and open the template in the editor.
descripcion1=\n A tree ABC (Complet Binary Tree) is a tree that is characterized by all nodes, \n except for the last level have two children: \n \n - The left subtree, where are located the keys smaller than the root.\n \n - The right subtree, where are located the keys larger than the root.
descripcion2=\n An AVL (Adelson-Velskii and Landis) tree, is a binary search tree, in which all \n subtree satisfies: \n \n - The left subtree, where are located the keys smaller than the root. \n - The right subtree, where are located the keys larger than the root.\n - Faith (T ') = 0, fe (T') = 1 or faith (T ') = -1, \n    where k is the balance factor of a binary tree T: \n \n  	faith (T) = depth (left (T))-depth (right (T))
descripcion3=\n In addition to the requirements imposed on a binary search trees, with red\u2013black trees: \n \n - A node is either red or black. \n - The root is black. (This rule is sometimes omitted. Since the root can always be \n    changed from red to black, but not necessarily vice-versa, this rule has little effect \n    on analysis.)\n - All leaves (NIL) are black. (All leaves are same color as the root.) \n - Both children of every red node are black. \n - Every simple path from a given node to any of its descendant leaves contains the same \n    number of black nodes.\n    These constraints enforce a critical property of red\u2013black trees: that the path from the \n    root to the furthest leaf is no more than twice as long as the path from the root to the \n    nearest leaf. The result is that the tree is roughly height-balanced. Since operations \n    such as inserting, deleting, and finding values require worst-case time proportional to \n    the height of the tree, this theoretical upper bound on the height allows red\u2013black trees \n    to be efficient in the worst case, unlike ordinary binary search trees. Red\u2013black trees \n    are in general not weight-balanced; that is, sibling nodes can have hugely differing \n    numbers of descendants.
descripcion4=\n If we perform the operation to insert a K KEY with VALUE V inside a tree, tree is \n inserted into the couple <clave, valued> corerspondiente insertion.\n \n POSSIBILITIES:\n \n * If the key K isn't in the tree, the tree will be introduced in the couple <clave, valued> \n \n * If the key K already exists in the tree, proceed to update its value.\n \n * If the key K has an undefined value will generate an ERROR.
descripcion5=\n If we make the removal of a KEY K of a tree shall be removed partner <key, value> \n \n POSSIBILITIES: \n \n * If the key K exists in the tree, will be removed and updated tree structure. \n \n * If the key K is not in the tree, you will get an ERROR.
descripcion6=\n If we make a query of a KEY K in a tree, we get the value of that key. \n \n POSSIBILITIES: \n \n * If the key K exists in the tree, indicated by message what is the value of that key. \n \n * If the key K is not in the tree, you will get an ERROR.
